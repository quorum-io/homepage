<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node by Quorum IO — Governance Infrastructure for Communities</title>
  <link rel="icon" href="favicon.ico">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <div class="noise"></div>
  
  <header>
    <nav>
      <a href="/" class="logo">
        <img src="logo.png" alt="Quorum IO" />
        <span class="logo-text">Quorum IO</span>
      </a>
      <div class="nav-links">
        <a href="#technology">How It Works</a>
        <a href="#principles">Principles</a>
        <a href="#network">Network</a>
        <a href="./whitepaper.html">Whitepaper</a>
        <a href="https://github.com/quorum-io/node" class="nav-cta">
          GitHub
          <svg class="icon-arrow" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 12L12 4M12 4H6M12 4V10"/>
          </svg>
        </a>
      </div>
      <button class="mobile-menu" aria-label="Menu">
        <span></span>
        <span></span>
      </button>
    </nav>
  </header>

  <main>
    <!-- Hero Section -->
    <section class="hero">
      <div class="hero-bg">
        <div class="gradient-orb orb-1"></div>
        <div class="gradient-orb orb-2"></div>
        <div class="gradient-orb orb-3"></div>
      </div>
      
      <div class="hero-content">
        <div class="hero-badge">
          <span class="badge-dot"></span>
          <span class="badge-text">v1.0 Alpha</span>
        </div>
        <h1>
          Communities that make<br>
          decisions together.
        </h1>
        <p class="hero-description">
          Node is governance infrastructure for groups who need consensus without compromise. 
          Proposals pass when two-thirds agree—verified by cryptography, reviewed by humans, 
          owned by no one.
        </p>
        <div class="hero-actions">
          <a href="https://github.com/quorum-io/node" class="btn btn-primary">
            Get Started
            <svg class="icon-arrow" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M4 12L12 4M12 4H6M12 4V10"/>
            </svg>
          </a>
          <a href="#technology" class="btn btn-ghost">
            See how it works
          </a>
        </div>
      </div>

      <!-- Abstract Network Visualization -->
      <div class="hero-visual">
        <canvas id="networkCanvas"></canvas>
        <div class="visual-overlay"></div>
      </div>
    </section>

    <!-- Metrics Bar -->
    <section class="metrics-bar">
      <div class="metrics-container">
        <div class="metric">
          <span class="metric-value">67% Supermajority</span>
          <span class="metric-label">Real consensus to pass proposals</span>
        </div>
        <div class="metric">
          <span class="metric-value">Quantum-Safe Signatures</span>
          <span class="metric-label">Dilithium3 post-quantum cryptography</span>
        </div>
        <div class="metric">
          <span class="metric-value">No Server</span>
          <span class="metric-label">Fully peer-to-peer</span>
        </div>
        <div class="metric">
          <span class="metric-value">Human-Verified</span>
          <span class="metric-label">People review, not algorithms</span>
        </div>
      </div>
    </section>

    <!-- Technology Section -->
    <section id="technology" class="section">
      <div class="section-header">
        <p class="section-label">How It Works</p>
        <h2>Real decisions, verified by real people</h2>
      </div>
      
      <div class="features-grid">
        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="10"/>
              <circle cx="12" cy="12" r="4"/>
              <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
            </svg>
          </div>
          <h3>Real Group Consensus</h3>
          <p>Proposals pass when two-thirds of the community agrees—not when a timer runs out. Your influence grows as you contribute meaningfully. No one votes on their own proposals.</p>
          <code>67% supermajority • Weighted voting • No self-votes</code>
        </article>

        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <path d="M3 9h18M9 3v18"/>
            </svg>
          </div>
          <h3>Tamper-Proof Records</h3>
          <p>Every piece of content gets a cryptographic fingerprint. Change a single character and the signature breaks. The network knows what was actually said.</p>
          <code>Content-addressed storage • Signed messages</code>
        </article>

        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M12 2L2 7l10 5 10-5-10-5z"/>
              <path d="M2 17l10 5 10-5"/>
              <path d="M2 12l10 5 10-5"/>
            </svg>
          </div>
          <h3>Built for the Long Term</h3>
          <p>Identity and votes are protected by Dilithium3 signatures—cryptography designed to withstand quantum computers. Your governance decisions remain verifiable for decades.</p>
          <code>Post-quantum signatures • Argon2 key derivation</code>
        </article>

        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/>
            </svg>
          </div>
          <h3>Private by Default</h3>
          <p>Direct messages are end-to-end encrypted using X25519 key exchange and ChaCha20-Poly1305. Only you and your recipient can read them. Both parties must consent before a conversation begins.</p>
          <code>E2E encryption • Mutual consent required</code>
        </article>

        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 6v6l4 2"/>
            </svg>
          </div>
          <h3>Content That Earns Its Place</h3>
          <p>Unused content naturally fades after a configurable period—but the community can vote to pin what matters. No algorithm decides what you see; the group does.</p>
          <code>Configurable decay • Community pinning</code>
        </article>

        <article class="feature-card">
          <div class="feature-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="11" cy="11" r="8"/>
              <path d="M21 21l-4.35-4.35"/>
            </svg>
          </div>
          <h3>Discover Communities</h3>
          <p>Browse a public directory of pools—communities organized by topic, passphrase-protected, invisible to outsiders. Find your people, then decide if you want to join.</p>
          <code>DHT discovery • Private membership</code>
        </article>
      </div>
    </section>

    <!-- Terminal Section -->
    <section class="section terminal-section">
      <div class="terminal-window">
        <div class="terminal-header">
          <div class="terminal-controls">
            <span></span><span></span><span></span>
          </div>
          <span class="terminal-title">Node v1.0</span>
        </div>
        <div class="terminal-body">
          <div class="terminal-line">
            <span class="prompt">$</span>
            <span class="command">cargo run -- 0.0.0.0:9070 ./data</span>
          </div>
          <div class="terminal-output">Node v1.0 — Governance Infrastructure</div>
          <div class="terminal-output dim">by Quorum IO</div>
          <div class="terminal-line">
            <span class="prompt">›</span>
            <span class="command">join-rendezvous</span>
          </div>
          <div class="terminal-output"><span class="highlight">[OK]</span> Joined discovery network</div>
          <div class="terminal-line">
            <span class="prompt">›</span>
            <span class="command">dht-search rust</span>
          </div>
          <div class="terminal-output"><span class="highlight">[FOUND]</span> 3 pools • Rust Developers, WebAssembly Guild, Systems Programming</div>
          <div class="terminal-line">
            <span class="prompt">›</span>
            <span class="command">auth my-secret-passphrase --name "My Community"</span>
          </div>
          <div class="terminal-output"><span class="highlight">[OK]</span> Pool set: 7f3a2b1c...</div>
          <div class="terminal-line">
            <span class="prompt">›</span>
            <span class="command typing" id="typingCommand"></span>
            <span class="cursor"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Principles Section -->
    <section id="principles" class="section">
      <div class="section-header">
        <p class="section-label">Principles</p>
        <h2>Three ideas. No compromises.</h2>
      </div>

      <div class="principles-grid">
        <div class="principle-card">
          <span class="principle-number">01</span>
          <h3>People, Not Algorithms</h3>
          <p>Joining requires explaining why you belong—and existing members decide if you do. Content quality is judged by human reviewers across five dimensions, not engagement metrics. Every decision involves real people making real choices.</p>
        </div>
        <div class="principle-card">
          <span class="principle-number">02</span>
          <h3>Proof, Not Trust</h3>
          <p>Cryptographic signatures verify every message. Content addressing proves nothing was changed. Your identity is bound to your keys. The network doesn't trust anyone—it verifies everyone.</p>
        </div>
        <div class="principle-card">
          <span class="principle-number">03</span>
          <h3>Your Data, Your Terms</h3>
          <p>No central server holds your community's data. No company can pull the plug. You run your own node, you control your keys, you own your participation. The network works for you, not the other way around.</p>
        </div>
      </div>
    </section>

    <!-- Network Section -->
    <section id="network" class="section">
      <div class="section-header">
        <p class="section-label">Network</p>
        <h2>Private communities on a public network</h2>
      </div>

      <div class="network-grid">
        <div class="network-visual">
          <div class="pool-visualization">
            <div class="pool-ring pool-ring-1">
              <div class="pool-node"></div>
              <div class="pool-node"></div>
              <div class="pool-node"></div>
            </div>
            <div class="pool-ring pool-ring-2">
              <div class="pool-node"></div>
              <div class="pool-node"></div>
              <div class="pool-node"></div>
              <div class="pool-node"></div>
            </div>
            <div class="pool-ring pool-ring-3">
              <div class="pool-node"></div>
              <div class="pool-node"></div>
            </div>
            <div class="pool-center">
              <span>Quorum</span>
            </div>
          </div>
        </div>

        <div class="network-info">
          <div class="info-card">
            <h4>Pools Are Private Spaces</h4>
            <p>Each pool is protected by a shared passphrase derived through Argon2. Members can see each other; outsiders can't. Different organizations share the network without sharing data.</p>
          </div>
          <div class="info-card">
            <h4>Share Files Securely</h4>
            <p>Send images, videos, and documents directly to your community. Large files split into 256KB verified chunks that reassemble automatically—with proof nothing was corrupted or modified.</p>
          </div>
          <div class="info-card">
            <h4>Threaded Discussions</h4>
            <p>Reply to any message to create a threaded conversation. See the full discussion tree. Never lose track of who said what—every message is signed and timestamped.</p>
          </div>
          <div class="info-card">
            <h4>Witness What Matters</h4>
            <p>Acknowledge content you've genuinely engaged with. Add reflections to signal deeper attention. Your witnessed engagement builds trust and helps surface quality contributions.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- CTA Section -->
    <section class="section cta-section">
      <div class="cta-content">
        <h2>Run your own node</h2>
        <p>Open source. Open governance. Join a community—or start your own.</p>
        <div class="cta-command">
          <code>git clone https://github.com/quorum-io/node && cd node && cargo run</code>
          <button class="copy-btn" onclick="navigator.clipboard.writeText('git clone https://github.com/quorum-io/node && cd node && cargo run')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="9" y="9" width="13" height="13" rx="2"/>
              <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
            </svg>
          </button>
        </div>
        <a href="https://github.com/quorum-io/node" class="btn btn-primary btn-lg">
          View on GitHub
          <svg class="icon-arrow" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 12L12 4M12 4H6M12 4V10"/>
          </svg>
        </a>
      </div>
    </section>
  </main>

  <footer>
    <div class="footer-content">
      <div class="footer-brand">
        <img src="logo.png" alt="Quorum IO" />
        <span>Quorum IO</span>
      </div>
      <div class="footer-links">
        <a href="https://github.com/quorum-io/node">GitHub</a>
        <a href="/whitepaper.html">Whitepaper</a>
        <a href="https://github.com/quorum-io/node/blob/main/README.md">Documentation</a>
        <a href="https://github.com/quorum-io/node/issues">Report Issues</a>
      </div>
      <p class="footer-copy">&copy; 2025 Quorum IO</p>
    </div>
  </footer>

  <script>
    // Mobile menu
    const mobileMenu = document.querySelector('.mobile-menu');
    const navLinks = document.querySelector('.nav-links');
    
    mobileMenu?.addEventListener('click', () => {
      navLinks.classList.toggle('open');
      mobileMenu.classList.toggle('open');
    });

    // Smooth scroll
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          navLinks.classList.remove('open');
          mobileMenu.classList.remove('open');
        }
      });
    });

    // Typing animation with correct command syntax
    const commands = [
      'propose We should add dark mode support',
      'vote 7f3a y "This would help accessibility"',
      'connect 192.168.1.20:9070',
      'reply 8b4c Great point about the UX',
      'witness 7f3a',
      'ack 7f3a "This resonates with my experience"',
      'dm-request abc1'
    ];
    let cmdIndex = 0;
    let charIndex = 0;
    const typingEl = document.getElementById('typingCommand');
    
    function type() {
      if (charIndex < commands[cmdIndex].length) {
        typingEl.textContent += commands[cmdIndex][charIndex];
        charIndex++;
        setTimeout(type, 50 + Math.random() * 30);
      } else {
        setTimeout(() => {
          typingEl.textContent = '';
          charIndex = 0;
          cmdIndex = (cmdIndex + 1) % commands.length;
          setTimeout(type, 400);
        }, 2200);
      }
    }
    setTimeout(type, 1500);

    // Stacked Wireframe Triangles with Traveling Particles
    const canvas = document.getElementById('networkCanvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let width, height;
    let centerX, centerY;
    let rotation = 0;
    let particles = [];
    
    // Triangle stack settings
    const TRIANGULAR_LAYERS = [
      { radius: 700, rotationOffset: 0, opacity: 0.5, vertexRadius: 6, speed: 1 },
      { radius: 400, rotationOffset: Math.PI / 6, opacity: 0.35, vertexRadius: 5, speed: -0.7 },
      { radius: 100, rotationOffset: Math.PI / 3, opacity: 0.25, vertexRadius: 4, speed: 0.5 },
    ];
    
    const ROTATION_SPEED = 0.0008;
    const VERTEX_GLOW_RADIUS = 20;
    const LINE_WIDTH = 1.5;
    
    // Particle settings
    const PARTICLE_SPAWN_MIN = 600;
    const PARTICLE_SPAWN_MAX = 1800;
    const PARTICLE_SPEED = 0.025;
    const PARTICLE_SIZE = 3;
    const MAX_PARTICLES = 20;
    
    function resizeCanvas() {
      const container = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      width = container.offsetWidth;
      height = container.offsetHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
      
      centerX = width * 0.5;
      centerY = height * 0.5;
    }
    
    // Get triangle vertices for a specific layer
    function getVertices(layer, baseRotation) {
      const vertices = [];
      const layerRotation = baseRotation * layer.speed + layer.rotationOffset;
      for (let i = 0; i < 3; i++) {
        const angle = layerRotation + (i * Math.PI * 2 / 3) - Math.PI / 2;
        vertices.push({
          x: centerX + Math.cos(angle) * layer.radius,
          y: centerY + Math.sin(angle) * layer.radius
        });
      }
      return vertices;
    }
    
    // Particle class for traveling between vertices
    class Particle {
      constructor(fromIndex, toIndex, layerIndex) {
        this.fromIndex = fromIndex;
        this.toIndex = toIndex;
        this.layerIndex = layerIndex;
        this.progress = 0;
        this.speed = PARTICLE_SPEED + Math.random() * 0.004;
        this.opacity = 0;
        this.fadeIn = true;
        this.trail = [];
        this.maxTrailLength = 12;
      }
      
      update(allLayerVertices) {
        // Update progress
        this.progress += this.speed;
        
        // Fade in/out
        if (this.fadeIn && this.opacity < 1) {
          this.opacity = Math.min(1, this.opacity + 0.05);
          if (this.opacity >= 1) this.fadeIn = false;
        }
        if (this.progress > 0.7) {
          this.opacity = Math.max(0, 1 - (this.progress - 0.7) / 0.3);
        }
        
        // Calculate current position
        const vertices = allLayerVertices[this.layerIndex];
        const from = vertices[this.fromIndex];
        const to = vertices[this.toIndex];
        this.x = from.x + (to.x - from.x) * this.progress;
        this.y = from.y + (to.y - from.y) * this.progress;
        
        // Update trail
        if (this.trail.length >= this.maxTrailLength) {
          this.trail.shift();
        }
        this.trail.push({ x: this.x, y: this.y, opacity: this.opacity });
        
        return this.progress < 1;
      }
      
      draw(ctx, layerOpacity) {
        if (this.opacity <= 0) return;
        
        const finalOpacity = this.opacity * (0.5 + layerOpacity);
        
        // Draw trail
        if (this.trail.length > 1) {
          for (let i = 1; i < this.trail.length; i++) {
            const point = this.trail[i];
            const prevPoint = this.trail[i - 1];
            const trailProgress = i / this.trail.length;
            const trailOpacity = trailProgress * finalOpacity * 0.5;
            
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(point.x, point.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${trailOpacity})`;
            ctx.lineWidth = PARTICLE_SIZE * trailProgress;
            ctx.lineCap = 'round';
            ctx.stroke();
          }
        }
        
        // Draw particle glow
        const glowGradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, PARTICLE_SIZE * 4
        );
        glowGradient.addColorStop(0, `rgba(255, 255, 255, ${finalOpacity * 0.8})`);
        glowGradient.addColorStop(0.5, `rgba(255, 255, 255, ${finalOpacity * 0.2})`);
        glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, PARTICLE_SIZE * 4, 0, Math.PI * 2);
        ctx.fillStyle = glowGradient;
        ctx.fill();
        
        // Draw particle core
        ctx.beginPath();
        ctx.arc(this.x, this.y, PARTICLE_SIZE, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${finalOpacity})`;
        ctx.fill();
      }
    }
    
    // Spawn particles randomly
    let nextSpawnTime = 0;
    
    function scheduleNextSpawn() {
      nextSpawnTime = Date.now() + PARTICLE_SPAWN_MIN + Math.random() * (PARTICLE_SPAWN_MAX - PARTICLE_SPAWN_MIN);
    }
    
    function spawnParticle() {
      if (particles.length >= MAX_PARTICLES) return;
      
      // Random layer
      const layerIndex = Math.floor(Math.random() * TRIANGULAR_LAYERS.length);
      
      // Random from/to vertices (different)
      const fromIndex = Math.floor(Math.random() * 3);
      let toIndex = Math.floor(Math.random() * 3);
      while (toIndex === fromIndex) {
        toIndex = Math.floor(Math.random() * 3);
      }
      
      particles.push(new Particle(fromIndex, toIndex, layerIndex));
    }
    
    function drawTriangle(vertices, layer, time) {
      const opacity = layer.opacity;
      
      // Draw edges with subtle glow
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Outer glow
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      for (let i = 1; i < 3; i++) {
        ctx.lineTo(vertices[i].x, vertices[i].y);
      }
      ctx.closePath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.2})`;
      ctx.lineWidth = LINE_WIDTH + 4;
      ctx.stroke();
      
      // Main lines
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      for (let i = 1; i < 3; i++) {
        ctx.lineTo(vertices[i].x, vertices[i].y);
      }
      ctx.closePath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.lineWidth = LINE_WIDTH;
      ctx.stroke();
      
      // Draw vertices with glow
      const pulse = 0.7 + 0.3 * Math.sin(time * 0.002);
      
      vertices.forEach((v, i) => {
        // Vertex glow
        const glowRadius = VERTEX_GLOW_RADIUS * (layer.vertexRadius / 6);
        const glowGradient = ctx.createRadialGradient(
          v.x, v.y, 0,
          v.x, v.y, glowRadius
        );
        glowGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.6 * pulse})`);
        glowGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.15 * pulse})`);
        glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.beginPath();
        ctx.arc(v.x, v.y, glowRadius, 0, Math.PI * 2);
        ctx.fillStyle = glowGradient;
        ctx.fill();
        
        // Vertex core
        ctx.beginPath();
        ctx.arc(v.x, v.y, layer.vertexRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * (0.8 + 0.2 * pulse)})`;
        ctx.fill();
        
        // Inner highlight
        ctx.beginPath();
        ctx.arc(v.x, v.y, layer.vertexRadius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.fill();
      });
    }
    
    function animate(time) {
      ctx.clearRect(0, 0, width, height);
      
      // Update rotation
      rotation += ROTATION_SPEED;
      
      // Get all layer vertices
      const allLayerVertices = TRIANGULAR_LAYERS.map(layer => getVertices(layer, rotation));
      
      // Spawn particles on random interval
      if (Date.now() > nextSpawnTime) {
        spawnParticle();
        scheduleNextSpawn();
      }
      
      // Update and filter particles
      particles = particles.filter(p => p.update(allLayerVertices));
      
      // Draw triangles from back to front (smallest/dimmest first)
      for (let i = TRIANGULAR_LAYERS.length - 1; i >= 0; i--) {
        drawTriangle(allLayerVertices[i], TRIANGULAR_LAYERS[i], time);
        
        // Draw particles for this layer
        particles
          .filter(p => p.layerIndex === i)
          .forEach(p => p.draw(ctx, TRIANGULAR_LAYERS[i].opacity));
      }
      
      animationId = requestAnimationFrame(animate);
    }
    
    function init() {
      resizeCanvas();
      particles = [];
      rotation = 0;
      scheduleNextSpawn();
      
      // Spawn a few initial particles across layers
      for (let i = 0; i < 5; i++) {
        setTimeout(() => spawnParticle(), i * 200);
      }
      
      animate(0);
    }
    
    window.addEventListener('resize', () => {
      cancelAnimationFrame(animationId);
      init();
    });
    
    init();

    // Intersection observer for scroll animations
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

    document.querySelectorAll('.feature-card, .principle-card, .info-card').forEach(el => {
      observer.observe(el);
    });
  </script>
</body>
</html>